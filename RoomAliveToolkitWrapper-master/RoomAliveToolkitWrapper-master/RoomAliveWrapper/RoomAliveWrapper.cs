using RoomAliveToolkit;
using System;
using System.IO;
using System.Text;
using CommandLine;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.ServiceModel.Discovery;
using System.Collections.ObjectModel;

namespace RoomAliveWrapper
{
    /*
    * Class used to setup command line options and parsing.
    */
    class CliOptions
    {
        [Option('d', "directory", Required = true, HelpText = "Path to toolkit setup.")]
        public string filepath { get; set; }

        [Option('f', "file", DefaultValue = "calibration", HelpText = "Filename to use for files generated by the calibration process.")]
        public string filename { get; set; }

        [Option('s', "setup", MutuallyExclusiveSet = "ops", HelpText = "Create a new caliration setup.")]
        public bool create { get; set; }

        [Option('c', "calibrate", MutuallyExclusiveSet = "ops", HelpText = "Begin calibration process.")]
        public bool calibrate { get; set; }

        [Option('i', "showIndices", MutuallyExclusiveSet = "ops", HelpText = "Show display indices on each projector.")]
        public bool showIndices { get; set; }

        [Option('h', "hideIndices", MutuallyExclusiveSet = "ops", HelpText = "Hide display indices.")]
        public bool hideIndices { get; set; }

        [Option('v', "verbose", HelpText = "Print information during execution.")]
        public bool verbose { get; set; }

        [Option('b', "debug", HelpText = "Display debug information and keep console window open after running.")]
        public bool debug { get; set; }

        [HelpOption]
        public string GetUsage()
        {
            var usage = new StringBuilder();
            usage.Append("RoomAlive Console Wrapper Quickguide\n");
            usage.Append("See github readme for further instructions. . .\n");
            return usage.ToString();
        }
    }

    /*
    * Helper class for output method wrappers.
    */
    class ConsoleOutput
    {
        bool _verbose = true;
        public bool Verbose
        {
            get { return _verbose; }
            set { _verbose = value; }
        }
        bool _debug = true;
        public bool Debug
        {
            get { return _debug; }
            set { _debug = value; }
        }
        
        public void Print(string value)
        {
            Console.WriteLine(value);
        }

        public void VerbosePrint(string value)
        {
            PrintVerbose(value, null);
        }

        public void PrintVerbose(string format, object arg0)
        {
            if (_verbose || _debug)
            {
                Console.WriteLine(format, arg0);
            }
        }

        public void DebugPrint(string value)
        {
            if (_debug)
            {
                Console.Error.WriteLine(value);
            }
        }

        public void DebugWaitForInput()
        {
            if (Console.IsOutputRedirected)
            {
                return;
            }
            else if (_debug)
            {
                Console.ReadLine();
            }
        }
    }

    class Wrapper
    {
        static ConsoleOutput cout;
        static CliOptions options;
        static string directory;
        static string fileName;
        static string XMLfilename;
        static ProjectorCameraEnsemble ensemble;


        static void Main(string[] args)
        {
            options = new CliOptions();
            var parser = new Parser (s => 
                {
                    s.MutuallyExclusive = true;
                    s.CaseSensitive = true;
                    s.HelpWriter = Console.Error;
                });
            cout = new ConsoleOutput();

            if (parser.ParseArguments(args, options))
            {
                // console output setup
                cout.Debug = options.debug;
                cout.Verbose = options.verbose;

                // file output setup
                directory = options.filepath;
                fileName = options.filename;
                XMLfilename = Path.Combine(directory, fileName + ".xml");

                // if we are creating a new setup, try to find online servers
                // and save the XML
                if (options.create)
                {
                    DiscoverServers();
                    SaveXML();
                }
                // else, try to load the XML file from location
                else if (LoadXML())
                {
                    if (options.calibrate)
                    {
                        RunCalibration();
                    }
                    else if (options.showIndices)
                    {
                        ShowDisplayIndices();
                    }
                    else if (options.hideIndices)
                    {
                        HideDisplayIndices();
                    }
                }
            }
            parser.Dispose();
            cout.DebugWaitForInput();
        }

        private static void RunCalibration()
        {
            try
            {
                Acquire();
                Solve();
                SaveXML();
                SaveObj();
            }
            catch (Exception e)
            {
                cout.DebugPrint(e.Message);
            }
        }
        
        // saves ensemble configuration to XML file
        static bool SaveXML()
        {
            try
            {
                ensemble.Save(XMLfilename);
                return true;
            }
            catch (Exception e)
            {
                cout.Print("Could not save configuration file to disk");
                cout.DebugPrint(e.Message);
            }
            return false;
        }

        // loades ensemble configuration from XML file
        static bool LoadXML()
        {
            try
            {
                using (var fileStream = new FileStream(XMLfilename, FileMode.Open))
                {
                    var knownTypeList = new List<Type>();
                    knownTypeList.Add(typeof(Kinect2Calibration));
                    var serializer = new DataContractSerializer(typeof(ProjectorCameraEnsemble), knownTypeList);
                    ensemble = (ProjectorCameraEnsemble)serializer.ReadObject(fileStream);
                }
                return true;
            }
            catch (FileNotFoundException)
            {
                cout.Print("Could not find XML configuration file.");
            }
            catch (Exception e)
            {
                cout.Print("Could not open configuration file.");
                cout.DebugPrint(e.Message);
            }
            return false;
        }

        // saves mesh obtained from calibration to file
        static bool SaveObj()
        {
            try
            {
                cout.VerbosePrint("Creating object file...");
                ensemble.SaveToOBJ(directory, directory + "/" + fileName + ".obj");
                cout.VerbosePrint("Object file created.");
                return true;
            }
            catch (Exception e)
            {
                cout.Print("Could not save object file to disk.");
                cout.DebugPrint(e.Message);
            }
            return false;
        }

        // discovers Kinect servers on the local net
        static Collection<EndpointDiscoveryMetadata> DiscoverCameras()
        {
            using (var discoveryClient = new DiscoveryClient(new UdpDiscoveryEndpoint()))
            {
                var findCriteria = new FindCriteria(typeof(KinectServer2))
                {
                    Duration = new TimeSpan(0, 0, 2)
                };
                var services = discoveryClient.Find(findCriteria);
                discoveryClient.Close();
                cout.PrintVerbose("Found {0} Kinect servers.", services.Endpoints.Count);

                return services.Endpoints;
            }
        }

        // discovers projector servers on the local net
        static Collection<EndpointDiscoveryMetadata> DiscoverProjectors()
        {
            using (var discoveryClient = new DiscoveryClient(new UdpDiscoveryEndpoint()))
            {
                var findCriteria = new FindCriteria(typeof(ProjectorServer))
                {
                    Duration = new TimeSpan(0, 0, 2)
                };
                var services = discoveryClient.Find(findCriteria);
                discoveryClient.Close();
                cout.PrintVerbose("Found {0} projector servers.", services.Endpoints.Count);

                return services.Endpoints;
            }
        }

        // coordinates server discovery and XML setup
        static void DiscoverServers()
        {
            cout.VerbosePrint("Finding Kinect and projector servers...");
            var findKServers =
                Task<Collection<EndpointDiscoveryMetadata>>.Factory.StartNew(DiscoverCameras);
            var findPServers =
                Task<Collection<EndpointDiscoveryMetadata>>.Factory.StartNew(DiscoverProjectors);

            var kServers = findKServers.Result;
            var pServers = findPServers.Result;
            ensemble = new ProjectorCameraEnsemble(pServers.Count, kServers.Count);
            for (int i = 0; i < kServers.Count; ++i)
            {
                ensemble.cameras[i].name = i.ToString();
                ensemble.cameras[i].hostNameOrAddress = kServers[i].Address.Uri.DnsSafeHost;
            }
            for (int i = 0; i < pServers.Count; ++i)
            {
                ensemble.projectors[i].name = i.ToString();
                ensemble.projectors[i].hostNameOrAddress = pServers[i].Address.Uri.DnsSafeHost;
                ensemble.projectors[i].displayIndex = 1; // Projectors are indexed 1 by default
            }
            cout.VerbosePrint("Server search complete.");
        }

        // runs toolkit acquire
        static void Acquire()
        {
            cout.VerbosePrint("Acquiring...");
            try
            {
                ensemble.CaptureGrayCodes(directory);
                cout.VerbosePrint("Acquire complete.");
            }
            catch (Exception e)
            {
                cout.VerbosePrint("Acquire failed.");
                throw;
            }
        }

        // runs toolkit solve
        static void Solve()
        {
            cout.VerbosePrint("Solving...");

            ensemble.DecodeGrayCodeImages(directory);
            try
            {
                ensemble.CalibrateProjectorGroups(directory);
                ensemble.OptimizePose();
                cout.VerbosePrint("Solved!");
            }
            catch (Exception e)
            {
                cout.VerbosePrint("Solve failed.");
                throw;
            }
        }

        // displays index of each display on each screen connected to every client
        static void ShowDisplayIndices()
        {
            try
            {
                foreach (var projector in ensemble.projectors)
                {
                    int screenCount = projector.Client.ScreenCount();
                    for (int i = 0; i < screenCount; i++)
                    {
                        projector.Client.OpenDisplay(i);
                        projector.Client.DisplayName(i, projector.hostNameOrAddress + ":" + i);
                    }
                }
                cout.VerbosePrint("Showing display indices.");
            }
            catch (Exception)
            {
                cout.VerbosePrint("Failed to show display indices.");
            }
        }

        // stops displaying on every screen of every connected client
        static void HideDisplayIndices()
        {
            try
            {
                foreach (var projector in ensemble.projectors)
                {
                    int screenCount = projector.Client.ScreenCount();
                    for (int i = 0; i < screenCount; i++)
                        projector.Client.CloseDisplay(i);
                }
                cout.VerbosePrint("Hid display indices.");
            }
            catch (Exception)
            {
                cout.VerbosePrint("Failed to hide display indices.");
            }
        }
    }
}
